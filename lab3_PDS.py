# -*- coding: utf-8 -*-
"""Lab3PDS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P5H1_Jk1qtBh7fFkCYBWD_2ZxzHDPpbc
"""

!pip show busio
!pip install board
!pip install time
!pip install busio
!pip install adafruit_ads1x15

import board
import busio
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn
import numpy as np
import matplotlib.pyplot as plt
import time

# Inicializa a interface I2C
i2c = busio.I2C(board.SCL, board.SDA)

# Cria um objeto ADS1115
ads = ADS.ADS1115(i2c)

class CircularBuffer:
    def __init__(self, size):
        self.size = size
        self.buffer = [None] * size
        self.head = 0
        self.tail = 0

    def is_empty(self):
        return self.head == self.tail and self.buffer[self.head] is None

    def is_full(self):
        return self.head == self.tail and self.buffer[self.head] is not None

    def enqueue(self, item):
        if self.is_full():
            self.tail = (self.tail + 1) % self.size

        self.buffer[self.head] = item
        self.head = (self.head + 1) % self.size

    def dequeue(self):
        if self.is_empty():
            return None

        item = self.buffer[self.tail]
        self.buffer[self.tail] = None
        self.tail = (self.tail + 1) % self.size
        return item

    def get_buffer(self):
        return self.buffer

# Exemplo de uso:
buffer_size = 128
buffer = CircularBuffer(buffer_size)

try:
    for _ in range(buffer_size):
        valor = AnalogIn(ads, ADS.P0)
        buffer.enqueue(valor)
        time.sleep(0.001)  # Atraso de 10 milissegundos entre leituras

except KeyboardInterrupt:
    print("\nPrograma encerrado pelo usuário.")

# Exibe o buffer após as leituras
print("Valores no buffer:")
for item in buffer.get_buffer():
    print("Tensao:", item.voltage)
h = np.random.randn(N)

# Calcula a convolução
convolution_output = np.convolve(
    [item.voltage for item in buffer.get_buffer() if item is not None],
    h,
    mode='full'
)

autocorrelation_output /= np.max(autocorrelation_output)

# Plota o gráfico de convoluçao
plt.stem(range(len(convolution_output)), convolution_output)
plt.title('Convolução entre x[n] e h[n]')
plt.xlabel('Índice (n)')
plt.ylabel('Saída da Convolução')
plt.grid(True)
plt.show()

import board
import busio
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn
import numpy as np
import matplotlib.pyplot as plt
import time

# Inicializa a interface I2C
i2c = busio.I2C(board.SCL, board.SDA)

# Cria um objeto ADS1115
ads = ADS.ADS1115(i2c)

class CircularBuffer:
    def __init__(self, size):
        self.size = size
        self.buffer = [None] * size
        self.head = 0
        self.tail = 0

    def is_empty(self):
        return self.head == self.tail and self.buffer[self.head] is None

    def is_full(self):
        return self.head == self.tail and self.buffer[self.head] is not None

    def enqueue(self, item):
        if self.is_full():
            self.tail = (self.tail + 1) % self.size

        self.buffer[self.head] = item
        self.head = (self.head + 1) % self.size

    def dequeue(self):
        if self.is_empty():
            return None

        item = self.buffer[self.tail]
        self.buffer[self.tail] = None
        self.tail = (self.tail + 1) % self.size
        return item

    def get_buffer(self):
        return self.buffer

# Exemplo de uso:
buffer_size = 128
buffer = CircularBuffer(buffer_size)
buffer_y = np.random.randn(buffer_size)

try:
    for _ in range(buffer_size):
        valor = AnalogIn(ads, ADS.P0)
        buffer.enqueue(valor)
        time.sleep(0.001)  # Atraso de 10 milissegundos entre leituras

except KeyboardInterrupt:
    print("\nPrograma encerrado pelo usuário.")

# Exibe o buffer após as leituras
print("Valores no buffer:")
for item in buffer.get_buffer():
    print("Tensao:", item.voltage)
deslocamento =200

# Calcula a autocorrelação
autocorrelation_output = np.correlate(
    [item.voltage for item in buffer.get_buffer() if item is not None],
    [item.voltage for item in buffer.get_buffer() if item is not None],
    mode='full'
)

autocorrelation_output /= np.max(autocorrelation_output)

# Plota o gráfico de autocorrelação
plt.stem(range(-buffer_size + 1, buffer_size), autocorrelation_output)
plt.title('Autocorrelação de x[n]')
plt.xlabel('Deslocamento Temporal (m)')
plt.ylabel('Autocorrelação Normalizada')
plt.grid(True)
plt.show()

import board
import busio
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn
import numpy as np
import matplotlib.pyplot as plt
import time

# Inicializa a interface I2C
i2c = busio.I2C(board.SCL, board.SDA)

# Cria um objeto ADS1115
ads = ADS.ADS1115(i2c)

class CircularBuffer:
    def __init__(self, size):
        self.size = size
        self.buffer = [None] * size
        self.head = 0
        self.tail = 0

    def is_empty(self):
        return self.head == self.tail and self.buffer[self.head] is None

    def is_full(self):
        return self.head == self.tail and self.buffer[self.head] is not None

    def enqueue(self, item):
        if self.is_full():
            self.tail = (self.tail + 1) % self.size

        self.buffer[self.head] = item
        self.head = (self.head + 1) % self.size

    def dequeue(self):
        if self.is_empty():
            return None

        item = self.buffer[self.tail]
        self.buffer[self.tail] = None
        self.tail = (self.tail + 1) % self.size
        return item

    def get_buffer(self):
        return self.buffer

# Exemplo de uso:
buffer_size = 128
buffer = CircularBuffer(buffer_size)

try:
    for _ in range(buffer_size):
        valor = AnalogIn(ads, ADS.P0)
        buffer.enqueue(valor)
        time.sleep(0.001)  # Atraso de 10 milissegundos entre leituras

except KeyboardInterrupt:
    print("\nPrograma encerrado pelo usuário.")

# Exibe o buffer após as leituras
print("Valores no buffer:")
for item in buffer.get_buffer():
    print("Tensao:", item.voltage)
buffer2 = np.random.randn(buffer_size)
deslocamento=100
# Calcula a correlaçao cruzada
autocorrelation_output = np.correlate(
    [item.voltage for item in buffer.get_buffer() if item is not None],
    np.roll(buffer2,deslocamento),
    mode='full'
)

autocorrelation_output /= np.max(autocorrelation_output)

# Plota o gráfico de autocorrelação
plt.stem(range(-buffer_size + 1, buffer_size), autocorrelation_output)
plt.title(f'Correlação Cruzada com Deslocamento de {deslocamento} amostras')
plt.xlabel('Deslocamento Temporal (m)')
plt.ylabel('Correlação Cruzada')
plt.grid(True)
plt.show()